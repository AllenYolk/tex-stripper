\section*{Results}
\label{sec:results}

\subsection*{Balancing expressivity and computational cost of dendritic spiking neuron}
\label{subsec:results-dendsn}

Distinguishing themselves from point neuron models widely employed in deep learning, multi-compartment models in computational neuroscience incorporate internal spatial structures and neuronal dynamics, as demonstrated in Figure \ref{fig:introduction}b. These intricate models depict neuronal morphology at a micrometer level and portray nonlinear dynamics using an extensive set of variables  \cite{schutter1994purkinje,poirazi2003arithmetic,hay2011pyramidal}, hence being capable of capturing complex behavior patterns of biological neurons. Nevertheless, their computational complexity impedes their application in deep neural networks, even with optimal acceleration methods in place \cite{zhang2023gpubased}. In response, \footnote{this is a footnote!!} reasonable simplifications are imperative to simulate a large population of complex neurons while preserving essential structural and computational properties.

\begin{figure}[tp!]
    \centering
    \includegraphics[width=\textwidth]{img/final/dendsn.drawio.pdf}
    \caption{
        \textbf{The DendSN model and its simulation results.}
        \begin{itemize}
        \item \textbf{a)} A schematic illustration of a rat layer-5 pyramidal cell's (L5PC) morphology \cite{beniaguev2021cortical}. 
        \item \textbf{b)} Our proposed DendSN model. It simplifies a multi-compartment model from three aspects: spatial structure, local dynamics, and signal transmission mechanism (blue boxes). A strength value is assigned to each dendritic branch at each time step, greatly enhancing the model's expressivity (red box).
        \item \textbf{c), d)} The computational overhead of different neuron models on a GPU. Here, ``DendSN, Parallel" means a DendSN whose dendritic dynamics are computed in parallel across both time and branches, while ``DendSN, Vanilla" is a DendSN simulated with the vanilla Euler method. ``Simulation time cost" refers to the total time required to sequentially process 512 randomly generated input samples of length $T$. The data in Subfigure d is obtained by averaging the time costs along all the conditions of $B$ while keeping the $T$ conditions.
        \end{itemize}
        \begin{enumerate}
        \item \textbf{e)} An illustration of the L5PC fitting experiment. For DendSN conditions, $B$ is set to $2$, representing the apical and basal dendrites. The presynaptic spikes are weighted by synaptic strengths, summed, and then fed into the branches. Parameters in the circles are optimized using gradient descent. For point SN conditions, the weighted sum of all the spikes is directly fed into the soma.
        \item \textbf{f)} The fitting losses of different models on the test set. Here, ``USwish2" means USwish dendritic nonlinear activation (see \nameref{sec:methods}) and $B=2$.
        \item \textbf{g),h)} The somatic membrane potential of a detailed multi-compartment L5PC model (black, ground truth), a point neuron model (blue), and a DendSN with a fully learnable branch strength matrix (orange, dashed). The trial is selected from the test set.
        \end{enumerate}
    }
    \label{fig:dendsn}
\end{figure}

Let's input the Introduction Section from main.tex:
\input{sections/1_introduction}

Let's include a table from main.tex:
\include{tables/bnws_ablation}

We propose the dendritic spiking neuron (DendSN) model illustrated in Figure \ref{fig:dendsn}b to strike this delicate balance. The simulation process is carried out over $T$ discrete time steps using the Euler method, just as the standard practice in SNNs. Structurally, the neuron comprises $B$ parallel dendritic branches and a soma. The $i$-th dendritic branch possesses a single state variable $V_i^d$, representing the dendritic local potential. At each time step $t$, the potential undergoes an update based on synaptic input $X_i$, and decays exponentially over time with a factor $\alpha$. 
\begin{equation}\label{eq:results-dend}
    V_i^d[t] = \alpha V_i^d[t-1] + X_i[t]
\end{equation}
$V_i^d[t]$ is then activated by a nonlinear function $f_i$  and subsequently weighted by a factor $K_{t,i}$, yielding the branch-to-soma signal $Y_i[t]$. The total input to the soma is the sum of the signals from all the branches. 
\begin{equation}\label{eq:results-dend2soma}
    Y[t] = \sum_{i=0}^{B-1}Y_i[t] = \sum_{i=0}^{B-1} K_{t,i} f_i(V_i^d[t]), \ t \in \{0,\dots,T-1\}
\end{equation}
Finally, the soma is a LIF neuron with a unary state variable $V^s$ as the somatic membrane potential \cite{lapicque1907lif}. It charges through the aggregated dendrite-to-soma signal $Y$, decays exponentially with a factor $\beta$, emits a spike when $V^s$ exceeds a threshold $V_{\mathrm{th}}^s$, and resets to $V^{s}_{\mathrm{reset}}$ after firing. The somatic dynamics can be described as
\begin{equation*}\label{eq:results-LIFsoma}
    \begin{aligned}
        H^s[t] &= \beta V^s[t-1] + (1-\beta)Y[t] \\ 
        S[t] &= \Theta(H^s[t] - V^s_{\mathrm{th}}) \\
        V^s[t] &= (1 - S[t])H^s[t] + S[t]V^s_{\mathrm{reset}}
    \end{aligned}
\end{equation*}
where $H^s$ is the somatic potential before spike emission, and $\Theta$ is the Heaviside step function.

\begin{table}[t]
\centering
\caption{
    You know, this is a table!!! Yes! Look at me!
}
\label{tab:bnws-ablation}
\begin{tabularx}{0.48\textwidth}{@{}cccCCCC@{}}
    \toprule
    \multirow{2}{*}{Method} & \multirow{2}{*}{sWS} & \multirow{2}{*}{BN} & \multicolumn{2}{c}{Seq. CIFAR-10} & \multicolumn{2}{c}{Seq. CIFAR-100} \\ \cmidrule(lr){4-5} \cmidrule(lr){6-7} 
    &  &  & Acc$_A$\% & Acc$_O$\% & Acc$_A$\% & Acc$_O$\% \\ \midrule
    \multirow{3}{*}{\rotatebox{90}{asdljfl}} & \checkmark & \crossmark & 73.31 & 73.64 & 46.60 & 46.92 \\
    & \crossmark & \checkmark & 5dsaf68 & 55.45 & 2asdf9 & 2ii \\
    & \crossmark & \checkmark$^\ddagger$ & 74.48 & 74.26 & 46asdf & 1114 \\ \midrule
    \multirow{4}{*}{\rotatebox{90}{OasdfR}} & \crossmark & \crossmark & 73.57 & 9435 & 44.45 & 45.25 \\
    & \checkmark & \crossmark & 73.4as-8 & sadf;o & 46.43 & 46.62 \\
    & \highlightcell \crossmark & \highlightcell \checkmark$^\ddagger$ & \highlightcell \textbf{75.06} & \highlightcell \textbf{74.99} & \highlightcell \textbf{47.01} & \highlightcell \textbf{47.28} \\
    & \checkmark & \checkmark$^\ddagger$ & 73.31 & 72.94 & 46.17 & 46.50 \\ \bottomrule
\end{tabularx}
\end{table}

Compared to detailed multi-compartment neurons, DendSN makes simplifications on spatial structure, source of nonlinearity, and dendritic local dynamics to reduce its computational complexity (see the blue boxes in Figure \ref{fig:dendsn}b). Firstly, the dendritic tree is portrayed as $B$ electrically segregated branches, each modeled as a single compartment. This abstraction is a nod to the common presence of multiple dendritic branches in biological neurons like pyramidal cells \cite{cajal1888estructura,ishizuka1995quantitative} (Figure \ref{fig:dendsn}a) while intentionally forgoing intricate morphological details. It not only significantly reduces memory costs for representing neuronal morphology, but also eliminates the need for transmitting signals between dendritic compartments, improving simulation efficiency. Secondly, nonlinear branch activation functions $\mathcal{F} = \{f_i\}_{i=0}^{B-1}$ are introduced to directly map dendritic states to branches' overall contributions to somatic potential change (see Supplementary Information \ref{supsec:dendritic-activation-function} for more details). Dendritic nonlinearity, one of the key computational properties of dendritic computation, is attached to the model in a general manner by these element-wise functions. Hence, we don't have to explicitly model the complex biophysical processes of gated dendritic ion channels using additional state variables and simulate their dynamics at high temporal resolution. Thirdly, since all the nonlinear components are shifted to the dendrite-to-soma signal forwarding process, the local dynamics of each dendritic state $V^d_i$ remain completely linear, merely reflecting passive electrical property \cite{payeur2019dendriticinfo,mengual2020dendsoma}. Thanks to their linearity, dendritic states can be updated in parallel across different branches as well as time steps. The acceleration algorithm of dendritic state computation is further explained by Equation~\eqref{eq:dendrite-acceleration-raw} and \eqref{eq:dendrite-acceleration-vec} in \nameref{sec:methods}.

Under these simplifications, DendSN can be simulated with high efficiency on parallel computing devices like GPUs. As shown in Figure \ref{fig:dendsn}c, the simulation time cost of DendSN remains almost constant as the number of dendritic branches $B$ increases, whether the acceleration of dendritic state update is applied or not. We attribute the constancy to the parallel arrangement of dendritic compartments, which allows for simultaneous updates of all the B dendritic states. Detailed multi-compartment models with $B$ dendritic compartments, by contrast, inevitably suffer from a noticeable increase in simulation time cost as $B$ grows, since the state of a particular compartment depends on the states of all its parent nodes \cite{zhang2023gpubased}. Apart from that, Figure \ref{fig:dendsn}d suggests that the simulation time costs of both point neuron and DendSN grow linearly with the number of time steps $T$. If the parallelism of dendritic state update across time is exploited, DendSN's simulation efficiency can be boosted to a level almost identical to that of the point neuron. Thus, the extra computational load imposed by dendrites is negligible in practice. These observations indicate that DendSN is computationally more affordable than conventional multi-compartment models, and holds promise for application in deep neural networks.

Despite its relatively low computational cost, DendSN retains a remarkable expressivity, mainly due to the enhancement of the branch weighting mechanism (see the red box in Figure \ref{fig:dendsn}b). The branch strength matrix $\mathbf{K}=[K_{t,i}]_{T\times B}$ assigns weights to different branches at different time steps, having the capacity to model the complex dependency of the somatic potential on dendritic states. To show that $\mathbf{K}_{T\times B}$ is the key factor endowing DendSN with the ability to capture crucial computational properties of biological neurons, we conduct a fitting experiment using activity data from a multi-compartment biophysical model of a layer-5 pyramidal cell \cite{beniaguev2021cortical}, as illustrated in Figure \ref{fig:dendsn}e. By leveraging gradient descent to learn both the synaptic weights and $\mathbf{K}$ (if DendSN is used), a single reduced neuron model can approximate the mapping from presynaptic spikes to somatic membrane potential of the detailed model. Figure \ref{fig:dendsn}f demonstrates that DendSNs with fully learnable $\mathbf{K}$ can achieve significantly better performances than a point LIF model, regardless of the dendritic activation function used. DendSN with non-monotonic Mexican hat dendritic nonlinearity yields the lowest mean squared error (MSE) on the test set, about $56\%$ of LIF neuron's MSE. However, if $\mathbf{K}$'s degree of freedom is restricted by setting it as a constant matrix or enforcing its rows or columns to be identical, the approximation and generalization performance of DendSN will degrade to LIF's level. To be worse, models with Mexican hat dendritic activation function may fail to converge on the training set under these constraints. In Figure \ref{fig:dendsn}g, we visualize the potential sequences of the original biophysical model (black), a LIF neuron (blue), and a DendSN with fully learnable $\mathbf{K}$ and Mexican hat activation (orange, dashed), given the same input spike train. Notably, DendSN approximates the ground truth with high fidelity when the somatic potential is far below the firing threshold, while the potential of the point neuron fluctuates severely and deviates from the ground truth. The smoothness of DendSN's potential trace is a direct result of its passive dendritic dynamics, which proves to be beneficial in this task. Although DendSN fails to predict the potential when the ground truth is close to the firing threshold (see the upper right box in Figure \ref{fig:dendsn}g, as well as Figure \ref{fig:dendsn}h), the decent performance in the subthreshold regime indicates DendSN's solid biological plausibility and marvelous expressivity.

In summary, DendSN stands as a streamlined yet expressive model for dendritic neurons. The branch weighting mechanism enhances the neuron's capacity, while the simplifications of dendritic morphology and nonlinear dynamics enable parallel computation across branches and time, reducing computational overhead. Its excellent expressivity and efficiency make it suitable for deep learning applications.

\subsection*{Dendritic spiking neural networks and their supervised training}
\label{subsec:results-dendsnn}

\begin{figure*}[tp!]
    \centering
    \includegraphics[width=\textwidth]{img/final/dendsnn.drawio.pdf}
    \caption{
        \textbf{Dendritic spiking neural networks and their supervised learning performance.}
        \textbf{a),b)} Detailed illustrations showcasing how input features $\mathbf{X}$ are assigned to different dendritic branches of a DendSN layer following either a fully connected layer (Subfigure a) of a 2D convolutional layer (Subfigure b).
        \textbf{c)} A comparison between a fully connected point SNN and a DendSNN with similar architecture. By replacing the point neuron layers with DendSN layers and adjusting the number of channels, a point SNN architecture can be easily converted to a DendSNN.
        \textbf{d)} Classification accuracies on the FashionMNIST benchmark. DendSNNs consistently outperform point SNNs, no matter which dendritic activation functions are used, how many dendritic branches are employed, and how branch strength matrices are set.
        \textbf{e)} A sample from the event-based N-MNIST dataset. 
        \textbf{d)} Classification accuracies on the N-MNIST dataset. DendSNNs achieve better performances than point SNNs on different time resolution settings ($T=4,8$).
    }
    \label{fig:dendsnn}
\end{figure*}

The efficacy of modern deep learning stems from the vast scale and well-crafted structure of neural networks. Deep network architectures like ResNet \cite{he2016resnet} and Transformer \cite{vaswani2017transformer} have been widely embraced for tackling machine learning problems in diverse domains. Pioneering works in the field of SNN have leveraged these advantageous design principles and built up their spiking counterparts, outperforming those plain and shallow SNNs \cite{zheng2020going,fang2021sew,hu2023advancing,zhou2023spikformer,zhou2023spikingformer,yao2023spikedriventransformer,yao2024spikedriventransformer}. Here, we integrate our DendSN into various deep SNNs with commonly used architectures, aiming to fully harness both the expressive power of DendSN and the capabilities of deep networks for tackling complex tasks.

To embed DendSNs into deep SNNs, an ensemble of neurons is first organized as a layer to facilitate tensor-based parallel simulation. For simplicity, we assume that all DendSNs in the layer share the same neuronal parameters $\alpha, \mathcal{F}, \beta$, except for the branch strength matrix $\mathbf{K}$. By default, all the neuronal parameters stay constant during both training and inference to avoid introducing extra learnable weights. The DendSN layer is positioned after a weight layer, forming a weight-DendSN block. The weight layer acts as synaptic connections; unlike previous works on dendritic deep learning, we do not impose an explicit sparsity constraint on the weight layer \cite{wu2018improved,zheng2024temporal} for the sake of simplicity and computational efficiency (see \ref{supsec:sparsity} for more details). The output of the weight layer is then folded along the channel (feature map) dimension into $B$ folds, where the $i$-th fold serves as the input to the $i$-th branch of all DendSNs in this layer.
\begin{equation}\label{eq:results-dendsnn}
\mathbf{X}_{i}^{(c)} = \mathbf{\tilde{X}}^{(cB+i)}, \ i \in \{0, \dots, B-1\}
\end{equation} Here, $\mathbf{\tilde{X}}^{(cB+i)}$ denotes the $(cB+i)$-th feature map of the weight layer's output, and $\mathbf{X}^{(c)}_i$ represents the input to the $i$-th dendritic branch of all DendSNs at channel $c$ in this layer (refer to \nameref{sec:methods} for detailed explanations). Consequently, a DendSN layer reduces the number of feature maps to $1/B$ of its original value, while retaining the size of the spatial dimensions. Note, Equation \eqref{eq:results-dendsnn} provides a universal solution to the input feature assignment problem for DendSN layers after different types of weight layers. Figure \ref{fig:dendsnn}a and Figure \ref{fig:dendsnn}b demonstrate two specific cases for fully connected and 2D convolutional layers, respectively. Supplementary Information \ref{supsec:pytorch-implementation} provides PyTorch implementations of a DendSN layer, either accelerated using temporal parallelism mentioned in the last section or not.

By cascading multiple weight-DendSN blocks, a deep DendSNN can be established. In fact, nearly all prevalent SNN designs can be converted to their DendSNN counterparts, thanks to the flexibility of the DendSN layer design as described in Equation \eqref{eq:results-dendsnn}. From the perspective of deep learning, DendSN layers serve as nonlinear activation functions, akin to the role point spiking neuron layers play in traditional SNNs. The main difference lies in the $1/B$ feature compression introduced by a layer of $B$-branch DendSNs. Therefore, a DendSNN architecture can be intuitively built up by first replacing the point spiking neuron layers in a conventional SNN with DendSN layers, and then adjusting the number of feature maps in the weight layers to align with the requirements of DendSN layers, as Figure \ref{fig:dendsnn}c suggests. This process can be implemented by popular deep learning frameworks like PyTorch \cite{paszke2019pytorch} in a plug-and-play manner, making DendSNNs highly accessible and flexible for deep learning practitioners.

In addition to flexibility, computational efficiency is a crucial requirement for deep DendSNNs. As illustrated in Figure \ref{fig:dendsn}d from the previous section, DendSN achieves low simulation cost by enabling parallel dendritic state updates both across branches and over time. This parallelism forms the algorithmic foundation for the efficient computation of deep DendSNNs. We also employ hand-crafted Triton kernels \cite{tillet2019triton} to leverage the full power of GPUs. This combination of algorithmic improvement and GPU-level acceleration allows DendSNNs to be trained and evaluated with high efficiency, ensuring their scalability for large-scale tasks.

The dynamics of a DendSN layer are fully differentiable, except for the Heaviside step function in the spike generation process. This issue can be circumvented using surrogate gradient \cite{neftci2019surrogate,zenke2021remarkable}, a common practice in directly trained point SNNs. Hence, DendSNNs can be trained in a supervised manner using gradient-based optimization methods like spatio-temporal backpropagation (STBP, a special case of BPTT) \cite{wu2018stbp}, enabling them to tackle a wide range of complex tasks. Here, we use two toy datasets to show the feasibility of training DendSNNs; in later sections, we will train DendSNNs with depths and scales comparable to prevalent deep point SNNs to solve more challenging tasks. By optimizing synaptic weights, 3-layer fully connected DendSNNs can achieve persistently better classification accuracies on the FashionMNIST \cite{xiao2017fashionmnist} dataset, compared to a point SNN with a similar architecture and equal number of learnable parameters, no matter which dendritic activation function and how may dendritic branches are employed (Figure \ref{fig:dendsnn}d). Moreover, the expressivity of DendSNNs can be further augmented by appropriately setting the branch strength matrices $\mathbf{K}$ for each DendSN in the network. We introduce three advanced models for setting up the strength matrices: direct learning, CBAM-based multi-dimensional attention on dendrite-to-soma signal (MA) \cite{woo2018cbam}, and SimAM-inspired parameter-free attention (PFA) \cite{yang2021simam}. Experiments on FashionMNIST indicate that PFA marginally improves the classification accuracy of DendSNN with 5 branches and Mexican hat dendritic activation (see Figure \ref{fig:dendsnn}d) even though no extra learnable parameters are brought in. The other two methods, in contrast, slightly degrade the model's generalization performance. Further experiments are conducted on the event-based N-MNIST \cite{orchard2015converting} dataset (Figure \ref{fig:dendsnn}e) using a convolutional network structure, under different temporal resolutions. Figure \ref{fig:dendsnn}f reveals a trend similar to that of FashionMNIST, except for the fact that learning $\mathbf{K}$ directly improves models' performance whereas PFA does not. For more information about the results of the experiments, refer to Table \ref{suptab:fmnist} and \ref{suptab:nmnist}. Notice that DendSNNs with MA cannot converge on the N-MNIST training set, so it is omitted from the figure. Our experience suggests that MA works on small fully connected DendSNNs with large $B$, while larger convolutional DendSNNs with MA mechanism and a small $B$ value are hard to train with MA at the beginning.

All in all, the flexibility and efficiency of DendSN make the construction of large-scale DendSNNs possible. DendSNNs can achieve better performance on supervised learning tasks than point SNNs, even without introducing extra learnable parameters. The superiority of DendSNNs on ordinary supervised learning tasks is the basis for their application in more challenging scenarios.

\subsection*{Dendritic modulation for continual learning}
\label{subsec:results-dbg}

Having presented our solution to incorporate dendritic computation into deep networks and the fact that DendSNNs exhibit remarkable expressivity, we now attempt to explore dendritic computation's influence on deep neural networks in demanding machine learning settings. Our initial focus is on continual learning, where a model should sequentially adapt to multiple data distributions without forgetting previously learned tasks. This ability is inherent in biological intelligence, reflecting the resilience of nervous systems. However, it poses a major challenge for artificial intelligent systems \cite{goodfellow2013empirical}. We argue that catastrophic forgetting of previously acquired knowledge can be alleviated by leveraging dendritic computation in a bio-inspired manner.

In the brain, sensory neurons receive not only bottom-up feedforward inputs but also top-down modulatory signals that adjust neuronal activity patterns \cite{roth2015thalamic}. These modulation inputs, typically originating from motor and prefrontal areas, encode higher-level information such as task context \cite{atiani2009task,popovkina2022task}, thus bringing task-specific properties to sensory processing. Wybo et al. \cite{wybo2023NMDA} revealed that NMDA-driven dendritic spikes may underlie contextual modulation of hierarchical sensory pathways, directing our attention to the role of dendritic modulation in task incremental learning.

What's more, the spatial location of synaptic sites on the dendritic tree greatly influences a biological neuron's response to synaptic inputs \cite{mel1994information,bono2017modelling}. A pertinent hypothesis is \textbf{synaptic clustering}, which suggests that functionally related synapses tend to cluster on dendrites as the result of structural plasticity, as shown in Figure \ref{fig:dbg}a. Previous studies have revealed that synaptic clusters are vital for increasing the brain's memory storage capacity \cite{kastellakis2015synaptic}, as functionally related inputs are preprocessed locally at the dendritic tree before integration at the soma, reducing interference from less relevant inputs. This hypothesis is supported by a wide range of anatomical and computational evidence \cite{takahashi2012locally,cichon2015branch,limbacher2020cluster}.

Inspired by dendritic modulation and synaptic clustering, we propose a novel algorithm named \textbf{dendritic branch gating (DBG)} to mitigate catastrophic forgetting of DendSNNs in task-incremental learning scenarios (see Figure \ref{fig:dbg}b and Supplementary Information \ref{supsec:dbg-pseudocode}). The index of the current task, denoted as $q$, serves as a top-down modulation signal and is fed to the network alongside the feedforward input during both training and inference. Note that the use of an extra context signal is a common practice in previously proposed architecture-based continual learning algorithms like XdG \cite{masse2018xdg}. However, instead of modulating synaptic weights as done in XdG, our algorithm sets the branch strength matrices of all DendSNs in the network based on $q$. Mathematically, the modulation process can be described as
\begin{equation}\label{eq:dbg-overall}
  \{\mathbf{K}^{(n)}\}_{n=0}^{N-1} \leftarrow \mathrm{DBG}(q)
\end{equation}
where $\mathbf{K}^{(n)}$ denotes the branch strength matrix of the $n$-th DendSN in the network, and $N$ is the total number of DendSNs. The remaining issue lies in mapping $q$ to a set of $N$ matrices with shape $T \times B$. The first approach, named $\mathrm{DBG}_{\mathrm{embedding}}$, assigns a set of dense but learnable matrices for each $q$. However, the density of $\mathrm{DBG}_{\mathrm{embedding}}$ deviates from the principle of synaptic clustering, which implies that the synaptic weights learned from a particular task should cluster on a small subset of dendritic branches. To achieve this goal, the $\mathrm{DBG}(q)$ mapping should yield sparse and temporally homogeneous (i.e. all $T$ rows being identical) matrices. In response, we propose two more strategies: $\mathrm{DBG}_{\mathrm{1hot}}$ and $\mathrm{DBG}_{\mathrm{random}}$, both of which satisfy these requirements. For sparse DBG implementations like these, training-time modulation prevents the learning of a new task from updating all the weights learned on previous tasks. Inference-time gating, on the other hand, ensures the activation of the correct subnetwork for each task. These properties are crucial for successfully avoiding catastrophic forgetting. Refer to \nameref{sec:methods} for a detailed explanation of DBG and its implementation, and Supplementary Information \ref{supsec:dbg-pseudocode} for pseudocodes.

\begin{figure}[tp!]
    \centering
    \includegraphics[width=\textwidth]{img/final/dbg.drawio.pdf}
    \caption{
        \textbf{Dendritic branch gating (DBG) for mitigating catastrophic forgetting in task-incremental learning.}
        \textbf{a)} An illustration of synaptic clustering in biological neurons. With the help of structural plasticity, functionally related synapses tend to cluster on dendrites, reducing interference from less relevant inputs.
        \textbf{b)} The DBG algorithm. During training and inference on task $q$, each DendSN in the network has its branch strength matrix $\mathbf{K}_{T\times B}$ set as a matrix that depends on the context signal $q$. This work proposes three implementations of DBG: $\mathrm{DBG}_{\mathrm{1hot}}$, $\mathrm{DBG}_{\mathrm{random}}$, and $\mathrm{DBG}_{\mathrm{embedding}}$. The first two implementations set $\mathbf{K}$ as a sparse and temporally symmetric matrix, aligning with the synaptic clustering hypothesis.
        \textbf{c)} The Permuted MNIST tasks. In task $D_q$, all the samples are permuted using $\mathrm{Perm}_q$.
        \textbf{d),e),f)} Results on the Permuted MNIST tasks. Subfigure e and f focus on DendSNNs with Mexican hat activation function to highlight the effect of DBG.
        \textbf{g)} The Split CIFAR-100 tasks.
        \textbf{h),i)} Results on the Split CIFAR-100 and Split TinyImageNet tasks.
    }
    \label{fig:dbg}
\end{figure}

To assess the task-incremental learning performance across different model types and modulation methods, we first use fully connected networks to solve the Permuted MNIST problem \cite{goodfellow2013empirical,masse2018xdg} consisting of $50$ tasks (Figure \ref{fig:dbg}c). Figure \ref{fig:dbg}d depicts the average accuracy curves concerning the number of learned tasks, where the descending trends reflect the impact of catastrophic forgetting on these models. Surprisingly, DendSNNs demonstrate greater resilience to catastrophic forgetting than point SNN, particularly in the early stages of incremental learning (i.e. less than 20 learned tasks), even without the assistance of DBG. As the number of learned tasks increases, DendSNNs with leaky ReLU and unlearnable Swish \cite{ramachandran2017swish} activation functions consistently outperform point SNN, while that with non-monotonic Mexican hat activation exhibits inferior performance. Next, we focus on the Mexican hat activation function cases, since the effect of DBG is more pronounced under this setting. Figure \ref{fig:dbg}f showcases the final average accuracies on 50 tasks. After $\mathrm{DBG}_{\mathrm{1hot}}$ is applied, DendSNNs achieve significantly higher average accuracy compared to the baseline point SNN. The overall performance improves with an increase in the number of dendritic branches $B$, as fewer tasks are allocated to each branch as $B$ increases; the performance of each task, however, does not dramatically degrade with the decrease in size of the subnetwork corresponding to the task, which is consistent with the observation in a previous study \cite{kim2022lottery}. When $B$ is set to $50$ and $\mathrm{DBG}_{\mathrm{1hot}}$ is adopted, the average accuracy even surpasses the best result point-SNN-based XdG \cite{masse2018xdg} can achieve. Figure \ref{fig:dbg}e plots the heat map of task $i$ accuracy after learning task $0$ to $j$ ($i$ for the row index and $j$ for the column index), indicating that the test accuracies of previous tasks do not degrade after learning new tasks with $\mathrm{DBG}_{\mathrm{1hot}}$ applied to a DendSNN with $50$ branches. If we use $\mathrm{DBG}_{\mathrm{1hot}}$ on a 5-branch DendSNN, the test accuracies of previous tasks do degrade, as each branch cannot afford to learn 10 tasks. $\mathrm{DBG}_{\mathrm{random}}$, on the other hand, enhances the models' continual learning performance, and even outperforms $\mathrm{DBG}_{\mathrm{1hot}}$ with $B \le 10$, as Figure \ref{fig:dbg}e and Figure \ref{fig:dbg}f show. Their average accuracies are comparable to those of XdG on point SNNs. Conversely, if $\mathrm{DBG}_{\mathrm{embedding}}$ is applied, no significant improvement in average accuracy is observed compared with point SNN. Indeed, the performance is even worse than that of the baseline point SNN when $B\le 25$. This underscores the importance of employing sparse gating in DBG and promotes synaptic clustering for achieving biological-inspired continual learning. For more information about the results, see Table \ref{suptab:pmnist}.

We conduct further experiments on the Split CIFAR-100 \cite{zenke2017continual} and Split TinyImageNet datasets (details are provided in \nameref{sec:methods}), where deeper convolutional networks (SEW ResNets \cite{fang2021sew}) are trained. We utilize DendSNs with leaky ReLU dendritic activation instead of Mexican hat nonlinearity, since the latter one cannot scale up to deeper networks (see Supplementary Information \ref{supsec:dendritic-activation-function}). The task setting of Split CIFAR-100 is outlined in Figure \ref{fig:dbg}g, with Split TinyImageNet following a similar structure. Figure \ref{fig:dbg}h and Figure \ref{fig:dbg}i show the average accuracies on the 10 Split CIFAR-100 tasks and 20 Split TinyImageNet tasks respectively. We observe similar trends to those observed in Permuted MNIST, with one notable exception: both vanilla DendSNNs with a small $B$ value and DendSNNs with $\mathrm{DBG}_{\mathrm{embedding}}$ outperform vanilla point SNNs. In addition, XdG yields intriguingly inferior performances on Split CIFAR-100. This phenomenon can be attributed to the fact that XdG zeros out most neuronal outputs, reducing the actual hidden size of each subnetwork and thereby impairing point SNNs' capacity. Sparse DBG methods, nevertheless, do not significantly hurt DendSNNs' capacity. For detailed experimental methodologies, refer to \nameref{sec:methods}. It is worth noting that DBG can be applied to DendSNNs together with powerful replay-based \cite{shin2017replay}, regularization-based \cite{kirkpatrick2017overcoming,zenke2017continual}, and optimization-based \cite{farajtabar2020orthogonal} methods widely used in point neural networks to boost up the continual learning performance to an even higher level.

Apart from continual learning, DBG can be easily extended to multitask learning settings. The results of Multi-(Fashion+MNIST) \cite{lin2019pareto} and UTKFace \cite{zhang2017utkface} multitask learning benchmarks are provided in Supplementary Information \ref{supsec:multitask-learning}, where DendSNNs with some DBG conditions can obtain marginally better performance than point SNNs. In a nutshell, DBG provides a unified bio-inspired solution for task-context-aware learning, leading the deep learning community to exploit the inner structure of neurons for lifelong learning and multitask learning.

\subsection*{Performances on diverse machine learning scenarios}

The exceptional task-context-aware learning performance of DendSNNs is propelled by a manually designed, although bio-inspired, algorithm. Additionally, we highlight the intrinsic advantages of the DendSN model for deep SNNs in this section.

Traditional ANNs and SNNs often falter when confronted with corrupted data, such as noisy inputs and adversarial attacks. They also encounter difficulties in few-shot learning scenarios, where training data are extremely scarce. By contrast, the human brain can handle all these challenges with ease, showcasing the remarkable robustness and generalization ability of biological neural circuits. We attribute this performance gap between artificial and biological systems to the disparities between real neural circuits and man-made models. To bridge this gap, a possible approach is to make artificial models more ``brain-like". We contend that the integration of dendritic computing into neural networks using DendSN has the potential to enhance performance and robustness in these challenging scenarios, even in the absence of specialized learning algorithms. We verify this hypothesis by conducting experiments on these scenarios, as listed in Figure \ref{fig:robustness}a. We compare the performances of models using point SNNs or DendSNNs as the whole model or merely the backbone.

\begin{figure}[tp!]
    \centering
    \includegraphics[width=\textwidth]{img/final/ml1.drawio.pdf}
    \caption{
        \textbf{DendSNNs' noise robustness.}
        \textbf{a)} In this section, we are going to test the performance of DendSNNs on three challenging machine learning scenarios: noise robustness, robustness against adversarial attacks, and few-shot learning.
        \textbf{b)} Samples from the FashionMNIST dataset with different levels of Gaussian noise infused (FashionMNIST-noise).
        \textbf{c)} DendSNNs' performances on FashionMNIST-noise. In the left plot, the model is trained on the clean training set and then tested on test sets with various noise levels. DendSNNs consistently outperform point SNNs. In the right plot, the model is trained on the noisy training set instead. Networks of DendSNs with 2 branches achieve the best performances.
        \textbf{d)} An illustration of the TinyImageNet-C dataset. Corruptions are added to each sample in the validation set. There are 15 corruption types, each with 5 levels of severity.
        \textbf{e), f)} DendSNNs' robustness on the CIFAR-10-C and TinyImageNet-C dataset. Their performances are compared with a point SNN (the pink dashed line), and mCE as well as rmCE are reported \cite{hendrycks2019benchmarking}. Lower mCE and rmCE are better. All the DendSNNs exhibit better robustness than the point SNN baseline on CIFAR-10-C, while on TinyIamgeNet-C, networks of DendSNs with 4 branches achieve significantly lower rmCEs compared to point SNN.
        \textbf{g)} An illustration of the DVS Gesture-C dataset. Six types of corruptions, each with 5 severity levels, are applied to each sample in the test set.
        \textbf{h)} DendSNNs' robustness on the DVS Gesture-C dataset. The baseline (the pink dashed line) is a point SNN. Five of the six DendSNNs achieve far lower rmCEs than point SNN. 
    }
    \label{fig:robustness}
\end{figure}

\subsubsection*{Noise robustness}

Noise robustness is crucial for deep learning models to maintain stable and reliable performance in real-world situations where data are susceptible to diverse sources of noise or corruption. To assess DendSNNs' robustness against noisy input, we conduct classification experiments on the FashionMNIST dataset \cite{xiao2017fashionmnist} with varying levels of Gaussian noise infused (see Figure \ref{fig:robustness}b). The models are first trained on either clean or noisy training sets, and then evaluated on the test sets with different noise levels. As shown in Figure \ref{fig:robustness}c, with the increase in noise level, the classification accuracies of all the models decrease. Nonetheless, when trained on the clean training set, DendSNNs consistently outperform point SNNs across all noise levels, showing better noise robustness. Even when trained with noisy data, networks of 2-branch DendSNs still achieve the best performances, exhibiting slower accuracy decrease rates than point SNNs. These findings suggest that multi-branch dendritic structures are beneficial for SNNs to resist noise.

However, Gaussian noise alone cannot cover the diverse corruption types in real life. To this end, we comprehensively test DendSNNs' robustness against various noise types on CIFAR-10-C and TinyImageNet-C \cite{hendrycks2019benchmarking}. The networks are first trained on the clean training set and frozen after that. Then, their error rates are obtained on the corrupted validation set, which comprises multiple corruption types (20 for CIFAR-10-C and 15 for TinyIamgeNet-C), each with 5 levels of severity (see Figure \ref{fig:robustness}d). We aggregate the models' error rates across corruption types and severities using the mean corruption error (mCE) and relative mean corruption error (rmCE) metrics introduced by Hendrycks et al. \cite{hendrycks2019benchmarking} (see \nameref{sec:methods}), and report the results in Figure \ref{fig:robustness}e and Figure \ref{fig:robustness}f. On the CIFAR-10-C task, all DendSNNs show better robustness than the pint SNN baseline (the pink dashed line) in terms of both mCE and rmCE. On TinyImageNet-C, which poses a greater challenge than the previous task, networks with 4-branch DendSN and leaky ReLU branch nonlinearity yield much lower rmCEs compared to the point SNN, while the mCE is slightly higher given lower test accuracies on the clean test set. Reducing the number of branches leads to a decrease in mCE (due to better performance on the clean test set) and an increase in rmCE (due to worse performance on the corrupted test set). From these observations, we can conclude that more dendritic branches are advantageous for noise robustness in sacrifice of clean accuracy.

In the aforementioned cases, noises are added to static images. We next investigate DendSNNs' robustness against corruptions added to event streams. Similar to CIFAR-10-C and TinyImageNet-C, we construct a corrupted version of the DVS Gesture dataset \cite{amir2017dvsgesture} by applying multiple types of corruptive transformations with different levels of severities to the events in the test set, as demonstrated in Figure \ref{fig:robustness}g. The transformation pipeline is further introduced in \nameref{sec:methods} and Table \ref{suptab:dvsgesturec}. Experimental procedures mirror those of CIFAR-10-C, and the resulting mCEs and rmCEs are demonstrated in Figure \ref{fig:robustness}h. Five of the six DendSNNs obtain significantly lower rmCEs and comparable mCEs compared to the baseline. Notice that a network of DendSNs with 2 branches, leaky ReLU activation function and learnable branch strengths can even achieve a rmCE of $0.502$ with a mCE of $1.061$, indicating remarkable robustness and comparable clean accuracy. Taken together, these results support the hypothesis that DendSNNs are more robust against noise than point SNNs.

\begin{figure}[tp!]
    \centering
    \includegraphics[width=\textwidth]{img/final/ml2.drawio.pdf}
    \caption{
        \textbf{DendSNNs' robustness against adversarial attack and few-shot learning performances.}
        \textbf{a)} The procedures of the adversarial attack experiment. The left part depicts an ``attack-on-model" setup, where adversarial attacks are applied directly to the model of interest.
        The right part, however, portrays a ``black-box" scenario, where another shared baseline model is employed to generate the adversarial samples.
        \textbf{b)} DendSNNs' robustness against adversarial attack, tested on the FashionMNIST benchmark. Their performances are compared to a point SNN with similar architecture (the pink dashed line). Lower rmAE indicates better robustness. In the left plot, attacks are applied directly to the models of interest, while in the right plot, attacks are applied to a shared baseline model.
        \textbf{c)} The procedures of few-shot learning using Prototypical Network. In each episode, there is a support set with multiple categories, each including several samples. These samples are processed by a trained feature extractor to generate one prototype for each category. These prototypes are then employed to classify the samples in the query set, using the nearest-neighbor principle.
        \textbf{d)} DendSNNs' performances on the miniImageNet few-shot learning benchmark. The models are trained using either episodic training (top) or classical training (bottom) pipeline, and then evaluated using 5-way 1-shot, 5-way 5-shot, 10-way 1-shot, and 10-way 5-shot classification accuracies. DendSNNs obtain better results compared to point SNN.
    }
    \label{fig:adv-fewshot}
\end{figure}

\subsubsection*{Robustness against adversarial attacks}

Besides noise, adversarial attacks represent another form of data corruption obtained by applying tiny yet intentionally worst-case perturbations to original samples \cite{goodfellow2014explaining}. Enhancing the robustness of neural networks against adversarial attacks is critical for security concerns. Previous studies have shown that deep SNNs are inherently more robust against adversarial attacks compared to non-spiking ANNs \cite{sharmin2019comprehensive,sharmin2020adversarial}. To check whether DendSNNs are less vulnerable to adversarial attacks than traditional SNNs, we conduct experiments based on the FashionMNIST dataset (the left part of Figure \ref{fig:adv-fewshot}a). After training the models of interest on the original dataset, we employ the fast gradient sign method (FGSM) \cite{goodfellow2014explaining} to generate adversarial samples with respect to these models. The models' error rates on both the original and adversarial test sets under various perturbation amplitudes $\epsilon$ are then recorded. Finally, we compute the relative mean adversarial error (rmAE), a metric similar to rmCE \cite{hendrycks2019benchmarking}, as a summarized measure (refer to \nameref{sec:methods}). The left plot in Figure \ref{fig:adv-fewshot}b compares rmAEs of different models. Remarkably, 10 out of 12 DendSNN configurations achieve lower rmAEs than the point SNN baseline, suggesting better robustness against adversarial attacks. Mexican hat dendritic nonlinearity can further enhance the models' resistance against attacks, and the network of DendSNs with 1 branch and parameter-free attentive branch strength yields the lowest rmAE of $0.7215$.

In the previous setup, adversarial attacks are applied directly to the models of interest. As a result, the test set for one model is different from another, leading to unfairness. To make the comparisons more reasonable, we next adopt a black-box adversarial attack setting, as shown in the right part of Figure \ref{fig:adv-fewshot}a. This time, adversarial test samples are generated with regard to a shared baseline model whose architecture is different from all models of interest. All the other settings are identical to the previous case. Despite the black-box adjustment, the final results demonstrated in the right part of Figure \ref{fig:adv-fewshot}b exhibit a trend similar to the previous setting. In summary, DendSNNs are more robust against adversarial attacks than point SNNs.

\subsubsection*{Few-shot learning}

Conventionally, supervised training of deep neural networks relies heavily on a substantial amount of labeled training data. Obtaining so much labeled data, however, is often costly and time-consuming. Hence, it's expected that machine learning models can effectively generalize to unseen domains and make accurate predictions when provided with very limited labeled training data. Here, we assess the few-shot learning capabilities of different backbone models using the miniImageNet benchmark \cite{vinyals2017matching}. We adopt the Prototypical Network paradigm \cite{snell2017prototypical} (Figure \ref{fig:adv-fewshot}c), and choose SEW ResNet18 architecture \cite{fang2021sew} as the backbone for feature extraction due to its relatively high performance. Both episodic training \cite{vinyals2017matching} and classical training pipelines are constructed (see \nameref{sec:methods} for details), and the models are evaluated using 5-way 1-shot, 5-way 5-shot, 10-way 1-shot, and 10-way 5-shot classification accuracies. As shown in Figure \ref{fig:adv-fewshot}d, all four types of accuracies under both episodic and classical training settings are elevated when a point SNN backbone is replaced with a DendSNN variant, regardless of the value of $B$ and the configuration of dendritic branch strengths. These results indicate that multiple nonlinear dendritic branches can enhance the feature extractor's robustness to variations in the input domain. DendSNNs are thus capable of extracting more generalizable features and distance metrics \cite{snell2017prototypical}. This insight offers potential solutions to alleviate the data-hungry bottleneck in various machine learning applications.
